```python
import pandas as pd 
import numpy as np 
import yfinance as yf 
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
```

### The case of OLMAR: regret with log-loss 
$b_t$ is the vector of percentages invested in each assets at time $t$. The strategy is **long-only**  
To update $b_t$ at each round solve the optimization problem:

$$
\begin{align*}
\text{minimize} & \,\frac{1}{2} \|b - b_t\|^2 \\
s.t. & \frac{1}{w}\sum_{i=t-w+1}^t \frac{p_i^j}{p_t^j} \leq \epsilon \\
& \|b_t\|_1 = 1 \\
& b \geq 0
\end{align*}
$$


```python
def prediction(prices,start=10,window=10):
    '''
    If I use a moving average on the prices the growth is much lower,
    however using a moving average on the relative prices goes to ~9%
    '''
    ma = np.mean(prices[start-window:start,:],axis=0)
#     print("**** DIMENSIONs:", ma.shape)
    return np.divide(ma,prices[start,:])
```


```python
def projection_simplex_sort(v, z=1):
    n_features = v.shape[0]
    u = np.sort(v)[::-1]
    cssv = np.cumsum(u) - z
    ind = np.arange(n_features) + 1
    cond = u - cssv / ind > 0
    rho = ind[cond][-1]
    theta = cssv[cond][-1] / float(rho)
    w = np.maximum(v - theta, 0)
    return w
```


```python
def olmar(eps, window, pred, portf):
    m = len(portf)
    mean = np.mean(pred)*np.ones(m)
    predicted_gain = np.dot(pred,portf)
    diff = np.subtract(pred,mean)
    den = np.linalg.norm(diff)**2
#     print("**** DEN:",den)
    _v = (eps-predicted_gain)/(den)
#     print("**** VV:", _v)
    lambda_ = max(_v,0) 
    ans = portf + lambda_*diff
    return projection_simplex_sort(ans)
```


```python
# historical data 
import json 
from requests import get
from config import * 
crypto_list=['BTC','ETH','XRP','USDT','BCH','BSV','LTC','EOS','BNB','XTZ']
series = []
for c in crypto_list:
    url = f'https://min-api.cryptocompare.com/data/v2/histoday?fsym={c}&tsym=USD&limit=400&api_key={API_KEY}'
    response = get(url)
    todos = json.loads(response.text)
    series.append(pd.DataFrame.from_dict(todos['Data']['Data'])['close'])
```


```python
df = pd.concat(series,axis=1)
df.columns = crypto_list
```


```python
n,m = df.shape
x = np.zeros((n-1,m))
for i in range(n-1):
    for j in range(m):
        x[i][j] = df.iloc[i+1,j]/df.iloc[i,j]
```


```python
pd.DataFrame(x,columns=crypto_list).head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>BTC</th>
      <th>ETH</th>
      <th>XRP</th>
      <th>USDT</th>
      <th>BCH</th>
      <th>BSV</th>
      <th>LTC</th>
      <th>EOS</th>
      <th>BNB</th>
      <th>XTZ</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1.001592</td>
      <td>1.005716</td>
      <td>1.001285</td>
      <td>0.997009</td>
      <td>1.318595</td>
      <td>1.008895</td>
      <td>1.025231</td>
      <td>1.010899</td>
      <td>0.997368</td>
      <td>0.955031</td>
    </tr>
    <tr>
      <th>1</th>
      <td>0.996731</td>
      <td>0.992350</td>
      <td>0.989734</td>
      <td>1.001000</td>
      <td>0.863225</td>
      <td>0.979378</td>
      <td>0.982281</td>
      <td>0.991914</td>
      <td>1.131926</td>
      <td>0.935448</td>
    </tr>
    <tr>
      <th>2</th>
      <td>0.982584</td>
      <td>0.980543</td>
      <td>0.980227</td>
      <td>0.996104</td>
      <td>1.145759</td>
      <td>0.971926</td>
      <td>0.983297</td>
      <td>1.000000</td>
      <td>0.976107</td>
      <td>1.029276</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1.004502</td>
      <td>1.003370</td>
      <td>1.001323</td>
      <td>1.001805</td>
      <td>0.994152</td>
      <td>0.998901</td>
      <td>0.997792</td>
      <td>1.027174</td>
      <td>0.964776</td>
      <td>0.956320</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1.026320</td>
      <td>1.042612</td>
      <td>1.027411</td>
      <td>1.003103</td>
      <td>1.053000</td>
      <td>1.026874</td>
      <td>1.047668</td>
      <td>1.142857</td>
      <td>1.029084</td>
      <td>1.096055</td>
    </tr>
  </tbody>
</table>
</div>




```python
def run_olmar(win=3, eps=10):
    b = np.ones((n,m))
    b[:win,:] = b[:win,:]/m 
    S = np.ones(n-1)
    S[:win] = 1 
    trash = 0
    for t in range(win,n-1):
        S[t] = S[t-1] * np.dot(b[t,:],x[t,:])
        pred = prediction(x,start=t,window=win)
        b[t+1,:] = olmar(eps,win,pred,b[t,:])
    return S
```


```python
eps = 100
win = 3
S = run_olmar(3,100)
```


```python
plt.figure(figsize=(10,5),dpi=120)
plt.plot(S/S[0])
plt.xlabel('ticks')
plt.ylabel('$S/S_0$')
plt.title(f'Gain')
i = i+1
plt.show()
```


![png](Olmar_files/Olmar_11_0.png)



```python
# Kelly growth 
kelly_growth = (1/len(S))*S[-1]/S[0]
print(f'kelly growth: {kelly_growth*100}%')
```

    kelly growth: 9.00768854604585%



```python
i = 8
asset_ts = []
for el in b:
    asset_ts.append(el[i])
plt.figure(figsize=(16,9),dpi=120)
plt.plot(btc_ts,'-o')
plt.xlabel('ticks')
plt.ylabel(crypto_list[i])
plt.title(f'{crypto_list[i]} Asset time evolution')
plt.show()
```


![png](Olmar_files/Olmar_13_0.png)



```python
len(btc_ts)
```




    5213




```python
def get_data(crypto_list:list,limit:int=400) -> pd.DataFrame:
    series = []
    for c in crypto_list:
        url = f'https://min-api.cryptocompare.com/data/v2/histoday?fsym={c}&tsym=USD&limit={limit}&api_key={API_KEY}'
        response = get(url)
        todos = json.loads(response.text)
        df = pd.DataFrame.from_dict(todos['Data']['Data'])[['time','open','high','low','close','volumefrom']]
        df.time = pd.to_datetime(df.time,unit='s')
        df.set_index('time', inplace=True)
        df.rename(columns={'volumefrom':'volume'},inplace=True)
        series.append(df)
    return series
```


```python
# from olmar_trading import * 
import pandas as pd
import backtrader as bt
from requests import get
import json
import backtrader.feeds as btfeeds
from config import *
```


```python
crypto_list=['BTC','ETH','XRP','USDT','BCH','BSV','LTC','EOS','BNB','XTZ']

datas = get_data(crypto_list)

class BuyAndHold(bt.Strategy):
    def next(self):
        if not self.getposition(self.data).size:
            self.order_target_percent(self.data, target=1.0)

def backtest(datas, strategy, plot=False, **kwargs):
    cerebro = bt.Cerebro()
    for data in datas:
        data_ = bt.feeds.PandasData(dataname=data)
        cerebro.adddata(data_)
    cerebro.addanalyzer(bt.analyzers.SharpeRatio, riskfreerate=0.0)
    cerebro.addanalyzer(bt.analyzers.Returns)
    cerebro.addanalyzer(bt.analyzers.DrawDown)
    cerebro.addstrategy(strategy, **kwargs)
    results = cerebro.run()
    if plot:
        cerebro.plot()
    return (results[0].analyzers.drawdown.get_analysis()['max']['drawdown'],
            results[0].analyzers.returns.get_analysis()['rnorm100'],
            results[0].analyzers.sharperatio.get_analysis()['sharperatio'])
            
dd, cagr, sharpe = backtest(datas, BuyAndHold, plot=True) 
print(f"Max Drawdown: {dd:.2f}%\nCAGR: {cagr:.2f}%\nSharpe: {sharpe:.3f}")

```


    ---------------------------------------------------------------------------

    ModuleNotFoundError                       Traceback (most recent call last)

    <ipython-input-5-08a4b65b3799> in <module>
         24             results[0].analyzers.sharperatio.get_analysis()['sharperatio'])
         25 
    ---> 26 dd, cagr, sharpe = backtest(datas, BuyAndHold, plot=True)
         27 print(f"Max Drawdown: {dd:.2f}%\nCAGR: {cagr:.2f}%\nSharpe: {sharpe:.3f}")


    <ipython-input-5-08a4b65b3799> in backtest(datas, strategy, plot, **kwargs)
         19     results = cerebro.run()
         20     if plot:
    ---> 21         cerebro.plot()
         22     return (results[0].analyzers.drawdown.get_analysis()['max']['drawdown'],
         23             results[0].analyzers.returns.get_analysis()['rnorm100'],


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/backtrader/cerebro.py in plot(self, plotter, numfigs, iplot, start, end, width, height, dpi, tight, use, **kwargs)
        972 
        973         if not plotter:
    --> 974             from . import plot
        975             if self.p.oldsync:
        976                 plotter = plot.Plot_OldSync(**kwargs)


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/backtrader/plot/__init__.py in <module>
         28         'Matplotlib seems to be missing. Needed for plotting support')
         29 else:
    ---> 30     matplotlib.use('TkAgg')
         31 
         32 


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/matplotlib/cbook/deprecation.py in wrapper(*args, **kwargs)
        294                 f"for the old name will be dropped %(removal)s.")
        295             kwargs[new] = kwargs.pop(old)
    --> 296         return func(*args, **kwargs)
        297 
        298     # wrapper() must keep the same documented signature as func(): if we


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/matplotlib/cbook/deprecation.py in wrapper(*args, **kwargs)
        356                 f"%(removal)s.  If any parameter follows {name!r}, they "
        357                 f"should be pass as keyword, not positionally.")
    --> 358         return func(*args, **kwargs)
        359 
        360     return wrapper


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/matplotlib/__init__.py in use(backend, warn, force)
       1278         rcParams['backend'] = rcParamsDefault['backend'] = name
       1279         try:
    -> 1280             from matplotlib import pyplot as plt
       1281             plt.switch_backend(name)
       1282         except ImportError as exc:


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/matplotlib/pyplot.py in <module>
       2280     dict.__setitem__(rcParams, "backend", rcsetup._auto_backend_sentinel)
       2281 # Set up the backend.
    -> 2282 switch_backend(rcParams["backend"])
       2283 
       2284 # Just to be safe.  Interactive mode can be turned on without


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/matplotlib/pyplot.py in switch_backend(newbackend)
        219         else "matplotlib.backends.backend_{}".format(newbackend.lower()))
        220 
    --> 221     backend_mod = importlib.import_module(backend_name)
        222     Backend = type(
        223         "Backend", (matplotlib.backends._Backend,), vars(backend_mod))


    ~/.pyenv/versions/3.8.1/lib/python3.8/importlib/__init__.py in import_module(name, package)
        125                 break
        126             level += 1
    --> 127     return _bootstrap._gcd_import(name[level:], package, level)
        128 
        129 


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/matplotlib/backends/backend_tkagg.py in <module>
    ----> 1 from . import _backend_tk
          2 from .backend_agg import FigureCanvasAgg
          3 from ._backend_tk import (
          4     _BackendTk, FigureCanvasTk, FigureManagerTk, NavigationToolbar2Tk)
          5 


    ~/.pyenv/versions/3.8.1/envs/trading/lib/python3.8/site-packages/matplotlib/backends/_backend_tk.py in <module>
          4 import os.path
          5 import sys
    ----> 6 import tkinter as tk
          7 from tkinter.simpledialog import SimpleDialog
          8 import tkinter.filedialog


    ~/.pyenv/versions/3.8.1/lib/python3.8/tkinter/__init__.py in <module>
         34 import sys
         35 
    ---> 36 import _tkinter # If this fails your Python may not be configured for Tk
         37 TclError = _tkinter.TclError
         38 from tkinter.constants import *


    ModuleNotFoundError: No module named '_tkinter'



```python

```
